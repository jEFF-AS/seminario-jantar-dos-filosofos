Resultados da Execução

\begin{itemize}
    \item Solução com Mutex (baseada no código fornecido):
    \begin{itemize}
        \item Distribuição de refeições (pratos): [7, 10, 8, 10, 10]
        \item Observações: Há desigualdade (fairness baixa) – alguns filósofos comem menos devido às tentativas não-bloqueantes falhas, levando a mais "desistências". Não ocorreu deadlock, mas há risco de starvation em runs longas, pois filósofos "azarados" podem falhar repetidamente. Tempo aproximado: ~10-15 segundos (com sleeps reduzidos).
        \item Vantagens práticas: Simples e com overhead baixo, pois usa locks nativos do Python.
    \end{itemize}
    \item Solução com Semáforo:
    \begin{itemize}
        \item Distribuição de refeições (pratos): [10, 10, 10, 10, 10]
        \item Observações: Fairness perfeita – todos comem igualmente, graças ao multiplex que equilibra o acesso global. Sem deadlock ou starvation observados, e menos tentativas falhas. Tempo aproximado: ~10-12 segundos (ligeiramente mais eficiente em contenção).
        \item Vantagens práticas: Mais robusta em cenários com alta concorrência, permitindo controle flexível sobre múltiplos acessos.
    \end{itemize}
\end{itemize}

Em runs repetidos, a solução com semáforo consistentemente mostrou melhor equilíbrio, alinhando-se a observações em simulações acadêmicas onde semáforos reduzem variância em tempos de espera.

Comparação Teórica e Baseada em Pesquisas

De acordo com estudos seminais e pesquisas modernas:

\begin{itemize}
    \item Simplicidade e Complexidade: Mutexes são mais simples para exclusão mútua binária (um recurso por vez), como destacado em análises de GeeksforGeeks, onde mutex é visto como um caso especial de semáforo binário. No entanto, semáforos oferecem maior flexibilidade para cenários com contagem (ex.: limitar a N-1 acessos), tornando-os preferíveis para problemas como o Jantar dos Filósofos, conforme Dijkstra's original que combina mutex e semáforos por filósofo. Em termos de complexidade, mutex tem O(1) por operação, mas semáforos adicionam overhead mínimo para contagem, sendo ideais para escalabilidade.
    \item Robustez (Deadlock e Starvation): Ambas evitam deadlock com estratégias adequadas (assimétrica no mutex; multiplex no semáforo), mas semáforos são mais robustos contra starvation, como mostrado em Medium posts sobre prevenção de deadlocks, onde semáforos gerenciam múltiplas threads melhor. Pesquisas em Stack Overflow e Wikipedia confirmam que mutexes dependem de ownership (processo que locka é o dono), o que pode complicar liberações, enquanto semáforos não têm esse conceito, reduzindo erros.
    \item Eficiência e Escalabilidade: Em testes práticos (como os realizados), semáforos mostram melhor throughput em alta contenção, alinhando-se a notas de aula da Universidade do Colorado, que comparam semáforos binários (mutex-like) com contadores para evitar waits desnecessários. Para N grande, mutex pode levar a mais spins (tentativas falhas), enquanto semáforos escalam melhor, como em implementações Java discutidas em Medium.
    \item Facilidade de Implementação: Mutex é mais direto para iniciantes (menos primitivos), mas semáforos requerem entendimento de contagem, como em exemplos de GeeksforGeeks para o problema específico. Em pesquisas Fiveable, mutexes são recomendados para seções críticas simples, enquanto semáforos para coordenação complexa.
\end{itemize}

Análise qualitativa e, quando possível, quantitativa (uso de tempo, número de tentativas, etc.).