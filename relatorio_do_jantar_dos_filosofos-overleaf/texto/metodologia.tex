\subsection{Abordagens de Resolução}
Serão exploradas as seguintes abordagens, com foco principal na utilização de semáforos e mutex.

\subsubsection{Abordagem Estatística}
Essa abordagem utiliza métodos probabilísticos ou randomizados para evitar deadlocks e starvation no problema do jantar dos filósofos. Inspirada na solução de Lehmann e Rabin (1981), os filósofos tentam pegar garfos de forma aleatória, com probabilidades ajustadas para quebrar ciclos de espera. Vantagens incluem simplicidade e ausência de deadlock garantida probabilisticamente; limitações envolvem possibilidade de starvation em cenários raros e falta de determinismo.

\subsubsection{Abordagem com Semáforos / Mutex}
Essa abordagem utiliza primitivos de sincronização para controlar o acesso aos recursos compartilhados (garfos). Mutex são locks binários que asseguram exclusão mútua: cada garfo é representado por um mutex, e um filósofo só come após adquirir ambos os mutex adjacentes. Para evitar deadlock, estratégias como ordenação de aquisição são empregadas – por exemplo, filósofos com índices pares adquirem o garfo esquerdo primeiro, enquanto ímpares adquirem o direito, quebrando a circularidade. Semáforos podem ser usados alternativamente para limitar o número de filósofos tentando comer simultaneamente (ex.: um semáforo inicializado em 4 permite que no máximo 4 filósofos peguem garfos, evitando o caso onde todos pegam um). Vantagens incluem simplicidade de implementação em linguagens como Python (via threading.Lock para mutex ou threading.Semaphore), eficiência em termos de overhead baixo e robustez contra condições de corrida. Limitações envolvem a possibilidade de starvation se não houver mecanismos de fairness, como envelhecimento de threads ou prioridades dinâmicas. A complexidade é O(1) por operação de aquisição, mas o tempo de espera pode variar em cenários de alta contenção. No código analisado, observa-se o uso exclusivo de mutex (threading.Lock), sem semáforos explícitos, com uma estratégia de aquisição condicional para prevenir deadlocks. Essa variação, inspirada em implementações como a encontrada em referências acadêmicas, demonstra que mutex sozinhos podem resolver o problema ao incorporar lógica de prevenção de ciclos.

\subsubsection{Abordagem via Teoria dos Grafos}
Modela o problema como um grafo onde filósofos são vértices e garfos são arestas, formando um grafo de recursos (geralmente circular). Usa detecção de ciclos para identificar deadlocks (via algoritmos de redução de grafos) e orientações acíclicas para escalonamento, como no Escalonamento por Reversão de Arestas (SER), maximizando concorrência mínima. Vantagens: análise formal de alocação de recursos e prevenção de ciclos; limitações: complexidade NP-completa para otimização em grafos grandes.

\subsubsection{Abordagem via SAT / CSP}
Modela o problema como um Constraint Satisfaction Problem (CSP), onde estados dos filósofos e garfos são variáveis com restrições (ex.: exclusão mútua), resolvidas por solvers para encontrar configurações deadlock-free. SAT (Satisfiability) estende isso codificando restrições em fórmulas booleanas. Vantagens: verificação formal de propriedades como ausência de deadlock; limitações: escalabilidade pobre para instâncias grandes devido à complexidade computacional.